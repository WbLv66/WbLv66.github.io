[{"categories":["笔记"],"content":"左值引用与右值引用 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:1:0","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"1. 左值与右值 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:2:0","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"1.1 左值 左值是可以取地址的对象，比如变量名和解引用的指针变量。 // 以下的a、p、*p、b都是左值 int a = 3; int* p = \u0026a; *p; const int b = 2; ","date":"2025-02-08","objectID":"/posts/1f15d8a/:2:1","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"1.2 右值 右值是不能取地址的对象，比如常量、临时变量、函数返回值、运算符返回值等。 double x = 1.3, y = 3.8; // 以下几个都是常见的右值 10; // 字面常量 x + y; // 表达式返回值 fmin(x, y); // 传值返回函数的返回值 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:2:2","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"2. 左值引用与右值引用 无论左值引用还是右值引用，都是给对象取别名。 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:3:0","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"2.1 左值引用 是指对左值的引用，作用是避免对象拷贝。 int\u0026 ra = a; ","date":"2025-02-08","objectID":"/posts/1f15d8a/:3:1","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"2.2 右值引用 是指对右值的引用，作用是延长对象的生命周期。 int\u0026\u0026 rr = 10; ","date":"2025-02-08","objectID":"/posts/1f15d8a/:3:2","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"2.3 对比与总结 左值引用可以指向左值，在指向右值时需要const修饰 右值引用可以指向右值，在指向左值时需要std::move() const int\u0026 rt4 = 8; // 临时对象的生命周期会被延长至引用的作用域结束 int t = 10; int\u0026\u0026 rrt = std::move(t); ","date":"2025-02-08","objectID":"/posts/1f15d8a/:3:3","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"3. 左值引用的实际意义 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:4:0","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"3.1 实际意义 传值传参和传值返回都会产生拷贝，而左值引用可以减少拷贝，从而提高效率。 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:4:1","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"3.2 短板 但当局部对象出了函数作用域以后就不存在了，所以不可以使用左值引用返回了。 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:4:2","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"4. 右值引用的实际意义 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:5:0","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"4.1 实际意义 解决函数参数的传递中（针对返回的将亡值）传递效率和空间不如意的问题。 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:5:1","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"4.2 短板 左值经过move()后，会失去原来的地址，所以无法再用之前的变量名访问。 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:5:2","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"4.3 完美转发 函数模板（不是类模板）中的\u0026\u0026不表示右值引用，而是万能引用，模板类型必须通过推断才能确定，其接收左值后会被推导为左值引用，接收右值后会被推导为右值引用。 void Func(int\u0026 x) { cout \u003c\u003c \"左值引用\" \u003c\u003c endl; } void Func(int\u0026\u0026 x) { cout \u003c\u003c \"右值引用\" \u003c\u003c endl; } template\u003ctypename T\u003e void f(T\u0026\u0026 t) // 万能引用 { Func(t); // 根据参数t的类型去匹配合适的重载函数 } 注意 右值引用后便失去了右值的属性。 f(10); 10是右值，传参后万能引用被推导为右值引用，但在f()函数中它变为了左值，因此实际调用的函数是void Func(int\u0026 x)。 为了实现完美转发，除了使用万能引用之外，我们还要用到std::forward（C++11），它在传参的过程中保留对象的原生类型属性。 void Func(int\u0026 x) { cout \u003c\u003c \"左值引用\" \u003c\u003c endl; } void Func(int\u0026\u0026 x) { cout \u003c\u003c \"右值引用\" \u003c\u003c endl; } template\u003ctypename T\u003e void f(T\u0026\u0026 t) // 万能引用 { Func(std::forward\u003cT\u003e(t)); // 根据参数t的类型去匹配合适的重载函数 } int main() { PerfectForward(10); // 仍是右值引用 return 0; } 注意 实现完美转发需要用到万能引用和 std::forward。 本笔记参考了「Hoshino373」的文章，原文链接为：https://blog.csdn.net/m0_59938453/article/details/125858335 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:5:3","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["技术文档"],"content":"升级Eigen库 usr/include/eigen3存放的是apt安装的Eigen库 /usr/local/include/eigen3存放的是源码安装的Eigen库 ","date":"2025-02-05","objectID":"/posts/0d48d55/:1:0","tags":["Eigen","linux"],"title":"升级Eigen库","uri":"/posts/0d48d55/"},{"categories":["技术文档"],"content":"1. 查看Eigen版本 sudo updatedb locate Macros.h|grep eigen3 gedit (相应位置)/usr/include/eigen3/Eigen/src/Core/util/Macros.h ","date":"2025-02-05","objectID":"/posts/0d48d55/:2:0","tags":["Eigen","linux"],"title":"升级Eigen库","uri":"/posts/0d48d55/"},{"categories":["技术文档"],"content":"2. 安装 # 下载Eigen源码,最好下载最新release版本 wget https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.tar.gz # 解压 mkdir eigen-3.4.0 tar -zxvf eigen-3.4.0.tar.gz -C ./eigen-3.4.0 #编译安装 mkdir build \u0026\u0026 cd build cmake .. sudo make install 只需将eigen文件复制到本地调用文件夹中就能完成对apt安装的覆盖 /usr/include sudo cp -r /usr/local/include/eigen3 /usr/include ","date":"2025-02-05","objectID":"/posts/0d48d55/:3:0","tags":["Eigen","linux"],"title":"升级Eigen库","uri":"/posts/0d48d55/"},{"categories":["技术文档"],"content":"在Linux上使用v2ray ","date":"2025-02-05","objectID":"/posts/b535a54/:1:0","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["技术文档"],"content":"1. 安装 v2ray-core 和 v2rayA ","date":"2025-02-05","objectID":"/posts/b535a54/:2:0","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["技术文档"],"content":"1.1 安装v2ray-core 参考网站：检测到 geosite.dat, geoip.dat 文件或 v2ray-core 可能未正确安装 – 爱思考的人 (aisikao.ren) v2ray-core:https://github.com/v2fly/v2ray-core 可以在上面任何一个网趾下载安装文件，下载的时候需要注意你的 CPU 架构，下载好之后解开压缩包，然后把可执行文件复制到 /usr/local/bin/ 或 /usr/bin/（推荐前者），把几个 dat 格式的文件复制到 /usr/local/share/v2ray/ 或者 /usr/share/v2ray/（推荐前者，xray 用户记得把文件放到 xray 文件夹），最后授予 v2ray/xray 可执行权限。 以下是用 bash 命令操作的示例： ## 注意要根据 CPU 架构安装不同版本 wget https://github.com/v2fly/v2ray-core/releases/latest/download/v2ray-linux-64.zip unzip v2ray-linux-64.zip -d ./v2ray sudo mkdir -p /usr/local/share/v2ray sudo cp ./v2ray/*dat /usr/local/share/v2ray sudo install -Dm755 ./v2ray/v2ray /usr/local/bin/v2ray ","date":"2025-02-05","objectID":"/posts/b535a54/:2:1","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["技术文档"],"content":"1.2 安装v2rayA 参考网站介绍 - v2rayA ## 注意要根据 CPU 架构安装不同版本 wget https://github.com/v2rayA/v2rayA/releases/latest/download/v2rayA/v2rayA/releases sudo apt install /path/download/installer_debian_xxx_vxxx.deb ### 自行替换 deb 包所在的实际路径 启动 v2rayA sudo systemctl start v2raya.service 设置开机自动启动 sudo systemctl enable v2raya.service ","date":"2025-02-05","objectID":"/posts/b535a54/:2:2","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["技术文档"],"content":"2. 使用 如果你通过 2017 端口 如 http://localhost:2017 无法访问 UI 界面，请检查你的服务是否已经启动。 在第一次进入页面时，你需要创建一个管理员账号，请妥善保管你的用户名密码，如果遗忘，使用sudo v2raya --reset-password命令重置。 设置 关闭IP转发和端口分享 透明代理/系统代理为启用:大陆白名单模式 透明代理/系统代理实现方式为tproxy 规则端口的分流模式为大陆白名单模式 防止DNS污染为关闭 特殊模式为关闭 TCPFastOpen为保持系统默认 多路复用为关闭 自动更新订阅为服务端启动时更新订阅 解析订阅链接/更新时优先使用为跟随透明代理/系统代理 ","date":"2025-02-05","objectID":"/posts/b535a54/:3:0","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["技术文档"],"content":"注意 关机前记得关闭服务，否则下次开机自动开启服务 ","date":"2025-02-05","objectID":"/posts/b535a54/:3:1","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["笔记"],"content":"docker命令 查看本地镜像 docker images 查看运行容器 docker ps 根据镜像创建容器 docker run --name my_container -dit --network=host my_image:tag /bin/bash --name：加上此参数可指定生成容器的名称，此参数位置在镜像id前 my_container 指定的容器名字 -d：打开后台运行 -i：打开控制台交互（不设置此选项退出容器后docker会自动清理未活动的容器） -t：支持终端登录 --network=host: 指定网络模式为主机网络 my_image:tag 是要使用的镜像名称和标签。不喜欢打这么多字的可以用id代替 /bin/bash 表示要在容器内启动 Bash Shell进行交互 进入容器正在执行的终端 docker attach 容器id # 如果使用exit退出，容器会停止运行 # 想退出容器但不想容器停止，则按住Ctrl+P+Q退出 进入容器并开启一个新的终端 docker exec -it 容器id /bin/bash # 如果使用exit退出，容器也不会停止 Docker容器向宿主机传送文件 docker cp container_id:\u003cdocker容器内的路径\u003e \u003c本地保存文件的路径\u003e 宿主机向Docker容器传送文件 docker cp 本地文件的路径 container_id:\u003cdocker容器内的路径\u003e ","date":"2025-02-05","objectID":"/posts/c41c58c/:1:0","tags":["docker","linux"],"title":"Docker","uri":"/posts/c41c58c/"},{"categories":["技术文档"],"content":"git ","date":"2025-02-05","objectID":"/posts/539f164/:1:0","tags":["git","linux","windows"],"title":"Git","uri":"/posts/539f164/"},{"categories":["技术文档"],"content":"1. ssh配置 创建本地密钥 cd ~/.ssh ssh-keygen -t rsa -b 4096 在~/.ssh添加文件config touch config vim config # 在里面添加 Host github.com User git IdentityFile ~/.ssh/mykey # 这里mykey换成你命名的私钥名称 ","date":"2025-02-05","objectID":"/posts/539f164/:2:0","tags":["git","linux","windows"],"title":"Git","uri":"/posts/539f164/"},{"categories":["技术文档"],"content":"CLion上使用ros ","date":"2025-02-05","objectID":"/posts/d8e0057/:1:0","tags":["Clion","ros","linux"],"title":"CLion上使用ros","uri":"/posts/d8e0057/"},{"categories":["技术文档"],"content":"1. 启动CLion 在ROS的根目录下(执行catkin_make的目录)执行如下(如果已将该路径添加到.bashrc文件则可跳过)： source ./devel/setup.bash 寻找CLion位置 # 使用locate sudo updatedb locate clion.sh # 使用find sudo find / -name \"clion.sh\" 打开CLion(sh 后面的路径因人而异) sh /home/robot/.local/share/JetBrains/Toolbox/apps/clion-nova/bin/clion.sh ","date":"2025-02-05","objectID":"/posts/d8e0057/:2:0","tags":["Clion","ros","linux"],"title":"CLion上使用ros","uri":"/posts/d8e0057/"},{"categories":["技术文档"],"content":"2. CLion 中打开一个 ROS 项目 一定要选择工作区的 src 目录以从中导入项目 设置build路径 默认情况下，CLion 将生成输出放在自动创建的 cmake-build-debug 或 cmake-build-release 目录中。对于 ROS 开发，这意味着将在 CLion 和运行 catkin _ make 的控制台中使用两种不同的构建。因此需要将 CLion 构建路径设置为 catkin 工作区目录 将CMake options(CMake 选项) 项修改如下，PATH后面是自己ROS的devel目录 -DCATKIN_DEVEL_PREFIX:PATH=/home/robot/catkin_ws/devel Generation path(构建目录) 项修改如下，路径是自己ROS的build目录 /home/robot/catkin_ws/build ","date":"2025-02-05","objectID":"/posts/d8e0057/:3:0","tags":["Clion","ros","linux"],"title":"CLion上使用ros","uri":"/posts/d8e0057/"},{"categories":["技术文档"],"content":"3. wsl+Clion+ros Toolchain选择WSL CMake options： -DCATKIN_DEVEL_PREFIX=/home/lwb/bit_ants/devel -DCMAKE_PREFIX_PATH=/home/lwb/bit_ants/devel -DCMAKE_PREFIX_PATH=/opt/ros/noetic -DPYTHON_EXECUTABLE=/usr/bin/python3 /opt/ros/noetic为你安装ros的目录 /home/lwb/bit_ants/deve为你当前项目的catkin目录 /usr/bin/python3使用的python版本 这些环境变量都可以通过catkin_make来获取，可以对比下cmake和catkin_make哪个环境变量不对就添加哪个 Build directory: ../build ","date":"2025-02-05","objectID":"/posts/d8e0057/:4:0","tags":["Clion","ros","linux"],"title":"CLion上使用ros","uri":"/posts/d8e0057/"},{"categories":["技术文档"],"content":"设置开机自启动 ","date":"2025-02-05","objectID":"/posts/12d83fa/:1:0","tags":["自启动","脚本","linux"],"title":"设置开机自启动","uri":"/posts/12d83fa/"},{"categories":["技术文档"],"content":"1. 创建一个启动脚本 cd ~ touch start_joy.sh chmod +x start_joy.sh ","date":"2025-02-05","objectID":"/posts/12d83fa/:2:0","tags":["自启动","脚本","linux"],"title":"设置开机自启动","uri":"/posts/12d83fa/"},{"categories":["技术文档"],"content":"2. 编辑脚本文件 vim start_joy.sh #!/bin/zsh source /opt/ros/noetic/setup.zsh source /home/nv/ants/devel/setup.zsh roslaunch vehicle_rea joy_control.launch ","date":"2025-02-05","objectID":"/posts/12d83fa/:3:0","tags":["自启动","脚本","linux"],"title":"设置开机自启动","uri":"/posts/12d83fa/"},{"categories":["技术文档"],"content":"3. 配置自动启动 创建 ~/.config/autostart 目录（如果它不存在的话） 使用 gnome-terminal 打开一个新的终端窗口并执行上述脚本。编辑 ~/.config/autostart 目录下的 .desktop 文件来实现这一点 mkdir -p ~/.config/autostart 创建一个新的 .desktop 文件，例如 start_joy.desktop vim ~/.config/autostart/start_joy.desktop [Desktop Entry] Type=Application Exec=gnome-terminal -- zsh -c \"~/start_joy.sh; exec zsh\" Hidden=false NoDisplay=false X-GNOME-Autostart-enabled=true Name[en_US]=Start Joy Name=Start Joy Comment[en_US]=Run start_joy.sh on startup Comment=Run start_joy.sh on startup 其中zsh可以替换为bash gnome-terminal可以替换为terminator ","date":"2025-02-05","objectID":"/posts/12d83fa/:4:0","tags":["自启动","脚本","linux"],"title":"设置开机自启动","uri":"/posts/12d83fa/"},{"categories":["技术文档"],"content":"升级CMake ","date":"2025-02-05","objectID":"/posts/84260000000000000000000000/:1:0","tags":["Cmake","升级"],"title":"升级Cmake","uri":"/posts/84260000000000000000000000/"},{"categories":["技术文档"],"content":"1. 安装 安装依赖 sudo apt install libssl-dev 去https://cmake.org/files/下载所需版本的源码。也可以使用wget下载，例如： wget https://cmake.org/files/v3.28/cmake-3.28.5.tar.gz tar -xvzf cmake-3.28.5.tar.gz 进入目录配置 cd cmake-3.28.5 chmod 777 ./configure ./configure make -j8 sudo make install ","date":"2025-02-05","objectID":"/posts/84260000000000000000000000/:2:0","tags":["Cmake","升级"],"title":"升级Cmake","uri":"/posts/84260000000000000000000000/"},{"categories":["技术文档"],"content":"2. 替换 最后使用新安装的cmake替换旧版本，其中/usr/local/bin/cmake为新安装的cmake目录 sudo update-alternatives --install /usr/bin/cmake cmake /usr/local/bin/cmake 1 --force ","date":"2025-02-05","objectID":"/posts/84260000000000000000000000/:3:0","tags":["Cmake","升级"],"title":"升级Cmake","uri":"/posts/84260000000000000000000000/"},{"categories":["技术文档"],"content":"vscode+clang 优势：代码提示更快；可以进行静态分析 ","date":"2025-02-05","objectID":"/posts/51dd9c5/:1:0","tags":["vscode","clang","linux"],"title":"Vscode+clang","uri":"/posts/51dd9c5/"},{"categories":["技术文档"],"content":"1. 在ubuntu上安装clang（推荐14及以上，有类型提示） wget https://apt.llvm.org/llvm.sh chmod u+x llvm.sh sudo ./llvm.sh 14 或者使用清华源 # 下载脚本 wget https://mirrors.tuna.tsinghua.edu.cn/llvm-apt/llvm.sh chmod +x llvm.sh ./llvm.sh 14 all -m https://mirrors.tuna.tsinghua.edu.cn/llvm-apt 将clang14和clang++14设为默认版本 sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-14 200 sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-14 200 # 列出已存在的替代项 sudo update-alternatives --display clang++ ","date":"2025-02-05","objectID":"/posts/51dd9c5/:2:0","tags":["vscode","clang","linux"],"title":"Vscode+clang","uri":"/posts/51dd9c5/"},{"categories":["技术文档"],"content":"2. 在vscode上安装插件 禁用微软c++插件的代码提示功能 方法一：删除vscode中提供的c++插件。 方法二：在setting.json加入\"C_Cpp.intelliSenseEngine\": “disabled”, 下载clangd插件和codelldb插件，codelldb插件在安装时会自动额外下载一个包 安装好后在clangd插件设置中勾选enable code completion，在clangd插件设置Arguments里面添加--compile-commands-dir=${workspaceFolder}/build 和 --header-insertion=never，Path设置为/usr/bin/clangd-14 ","date":"2025-02-05","objectID":"/posts/51dd9c5/:3:0","tags":["vscode","clang","linux"],"title":"Vscode+clang","uri":"/posts/51dd9c5/"},{"categories":["技术文档"],"content":"3. 配置.clang-format 此文件可以帮助代码格式化，放在主目录便可以了，为了让文件能在保存时自动格式化可以在settings.json里面写入\"editor.formatOnSave\": true 如下为我的.clang-format配置 # 基于那个配置文件 BasedOnStyle: google # 访问说明符的偏移(public private) AccessModifierOffset: -4 #缩进宽度 IndentWidth: 4 # 每行字符的限制，0表示没有限制 ColumnLimit: 80 ","date":"2025-02-05","objectID":"/posts/51dd9c5/:4:0","tags":["vscode","clang","linux"],"title":"Vscode+clang","uri":"/posts/51dd9c5/"},{"categories":["技术文档"],"content":"4. 配置.clang-tidy 此文件可以进行代码的静态分析，放在主目录便可以了，借助Cmake的输出文件可以让代码的静态分析更加准确。在CMakeLists.txt里面写入set(CMAKE_EXPORT_COMPILE_COMMANDS ON) 如下为我的clang-tidy配置 --- Checks: '-*, clang-analyzer-core.*, clang-analyzer-cplusplus.*, modernize-redundant-void-arg, modernize-use-bool-literals, modernize-use-equals-default, modernize-use-nullptr, modernize-use-override, google-explicit-constructor, google-readability-casting, readability-braces-around-statements, readability-identifier-naming.ClassCase, readability-identifier-naming.StructCase, readability-identifier-naming.TypedefCase, readability-identifier-naming.EnumCase, readability-non-const-parameter, cert-dcl21-cpp, bugprone-undelegated-constructor, bugprone-macro-parentheses, bugprone-macro-repeated-side-effects, bugprone-forward-declaration-namespace, bugprone-bool-pointer-implicit-conversion, bugprone-misplaced-widening-cast, cppcoreguidelines-narrowing-conversions, misc-unconventional-assign-operator, misc-unused-parameters' WarningsAsErrors: '' HeaderFilterRegex: '' CheckOptions: # 现代化（Modernize） - key: modernize-redundant-void-arg value: 'true' # 检查并移除函数声明中冗余的 void 参数。 - key: modernize-use-bool-literals value: 'true' # 建议使用布尔字面量 true 和 false 代替整数值 0 和 1。 - key: modernize-use-equals-default value: 'true' # 建议在默认构造函数、复制构造函数和赋值运算符中使用 = default，以简化代码。 - key: modernize-use-nullptr value: 'true' # 建议使用 nullptr 代替 NULL 或 0 来表示空指针。 - key: modernize-use-override value: 'true' # 建议在覆盖基类虚函数时使用 override 关键字，以增加代码的清晰性和安全性。 # Google 代码风格（Google） - key: google-explicit-constructor value: 'true' # 检查并建议在单参数构造函数中使用 explicit 关键字，以防止隐式转换。 - key: google-readability-casting value: 'true' # 检查并建议使用 C++ 风格的类型转换（如 static_cast、dynamic_cast、const_cast 和 reinterpret_cast）代替 C 风格的类型转换。 # 可读性（Readability） - key: readability-braces-around-statements value: 'true' # 建议在单行语句周围添加大括号，以提高代码的可读性和一致性。 - key: readability-identifier-naming.ClassCase value: 'CamelCase' # 类名应使用 CamelCase 风格，例如 MyClassName。 - key: readability-identifier-naming.StructCase value: 'CamelCase' # 结构体名应使用 CamelCase 风格，例如 MyStructName。 - key: readability-identifier-naming.TypedefCase value: 'CamelCase' # 类型定义应使用 CamelCase 风格，例如 MyTypeDef。 - key: readability-identifier-naming.EnumCase value: 'CamelCase' # 枚举名应使用 CamelCase 风格，例如 MyEnumName。 - key: readability-non-const-parameter value: 'true' # 检查并标识非 const 参数，以提高代码的可读性和安全性。 # CERT 安全编码标准（CERT） - key: cert-dcl21-cpp value: 'true' # 检查并标识在头文件中不应包含无命名空间的 using 声明和指令，以防止命名空间污染。 # Bug 检测（Bugprone） - key: bugprone-undelegated-constructor value: 'true' # 检查并标识未委托的构造函数，以确保构造函数的正确性。 - key: bugprone-macro-parentheses value: 'true' # 检查并建议在宏定义中使用括号，以防止潜在的错误。 - key: bugprone-macro-repeated-side-effects value: 'true' # 检查并标识宏中重复的副作用，以防止潜在的错误。 - key: bugprone-forward-declaration-namespace value: 'true' # 检查并标识命名空间前向声明的潜在问题。 - key: bugprone-bool-pointer-implicit-conversion value: 'true' # 检查并标识布尔指针的隐式转换，以防止潜在的错误。 - key: bugprone-misplaced-widening-cast value: 'true' # 检查并标识错误的宽化转换，以防止潜在的错误。 # C++ 核心指南（CppCoreGuidelines） - key: cppcoreguidelines-narrowing-conversions value: 'true' # 检查并标识可能导致数据丢失的窄化转换。 # 杂项（Miscellaneous） - key: misc-unconventional-assign-operator value: 'true' # 检查并标识不常见的赋值操作符重载，以确保代码的一致性和可维护性。 - key: misc-unused-parameters value: 'true' # 检测未使用的参数。 ... ","date":"2025-02-05","objectID":"/posts/51dd9c5/:5:0","tags":["vscode","clang","linux"],"title":"Vscode+clang","uri":"/posts/51dd9c5/"},{"categories":["技术文档"],"content":"配置zsh ","date":"2025-02-05","objectID":"/posts/bbea803/:1:0","tags":["linux","zsh"],"title":"Zsh","uri":"/posts/bbea803/"},{"categories":["技术文档"],"content":"1. 安装zsh sudo apt-get update sudo apt-get install zsh #设为默认 chsh -s $(which zsh) 不要关闭终端 ","date":"2025-02-05","objectID":"/posts/bbea803/:2:0","tags":["linux","zsh"],"title":"Zsh","uri":"/posts/bbea803/"},{"categories":["技术文档"],"content":"2. 安装oh-my-zsh sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" ","date":"2025-02-05","objectID":"/posts/bbea803/:3:0","tags":["linux","zsh"],"title":"Zsh","uri":"/posts/bbea803/"},{"categories":["技术文档"],"content":"3. 修改主题 vim ~/.zshrc 找到ZSH_THEME=“”，这句话，在双引号里面写上 crunch就可以啦 ","date":"2025-02-05","objectID":"/posts/bbea803/:4:0","tags":["linux","zsh"],"title":"Zsh","uri":"/posts/bbea803/"},{"categories":["技术文档"],"content":"4. 设置插件 zsh-autosuggestions：历史补全 下载安装 git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions vim ~/.zshrc进去配置zsh-autosuggestions plugins=( git # other plugins... zsh-autosuggestions ","date":"2025-02-05","objectID":"/posts/bbea803/:5:0","tags":["linux","zsh"],"title":"Zsh","uri":"/posts/bbea803/"},{"categories":["技术文档"],"content":"5. 终端美化 打开JSON设置，定位到Defaults里添加： 使用亚克力效果： \"useAcrylic\": true, \"opacity\": 80 设置背景： \"backgroundImage\": \"C:/Users/lwb/Desktop/picture/yourname.jpg\", \"backgroundImageOpacity\": 0.4 ","date":"2025-02-05","objectID":"/posts/bbea803/:6:0","tags":["linux","zsh"],"title":"Zsh","uri":"/posts/bbea803/"},{"categories":["技术文档"],"content":"升级gcc/g++ ","date":"2025-02-04","objectID":"/posts/4e49678/:1:0","tags":["gcc","g++","linux","升级"],"title":"升级GCC","uri":"/posts/4e49678/"},{"categories":["技术文档"],"content":"1. 查看版本 gcc -v g++ -v ","date":"2025-02-04","objectID":"/posts/4e49678/:2:0","tags":["gcc","g++","linux","升级"],"title":"升级GCC","uri":"/posts/4e49678/"},{"categories":["技术文档"],"content":"2. 下载指定版本 进入清华源下载相应版本 https://mirror.tuna.tsinghua.edu.cn/gnu/gcc wget https://mirror.tuna.tsinghua.edu.cn/gnu/gcc/gcc-14.1.0/gcc-14.1.0.tar.gz 解压文件进入目录,我下载的是gcc-14.1.0,版本因人而异 tar -xf gcc-14.1.0.tar.gz cd gcc-14.1.0 下载依赖包 ./contrib/download_prerequisites 创建一个用于编译GCC的目录： mkdir build \u0026\u0026 cd build 配置编译选项： ../configure --prefix=/opt/gcc-14.1.0 --enable-languages=c,c++ --disable-multilib 开始编译 make -j8 最后，安装GCC： sudo make install ","date":"2025-02-04","objectID":"/posts/4e49678/:3:0","tags":["gcc","g++","linux","升级"],"title":"升级GCC","uri":"/posts/4e49678/"},{"categories":["技术文档"],"content":"3. 设置软链接 查看系统gcc/g++版本 locate g++|grep /usr/bin/ locate gcc|grep /usr/bin/ 设置软链接的优先级 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 10 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 10 sudo update-alternatives --install /usr/bin/gcc gcc /opt/gcc-14.1.0/bin/gcc 20 sudo update-alternatives --install /usr/bin/g++ g++ /opt/gcc-14.1.0/bin/g++ 20 手动切换gcc与g++版本 sudo update-alternatives --config gcc sudo update-alternatives --config g++ ","date":"2025-02-04","objectID":"/posts/4e49678/:4:0","tags":["gcc","g++","linux","升级"],"title":"升级GCC","uri":"/posts/4e49678/"},{"categories":["技术文档"],"content":"4. 更新系统libstdc++版本 libstdc++是适应于g++的标准库,位于/usr/lib/x86_64-linux-gnu/下面 使用指令先看下系统目前都有哪些版本的 strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX 寻找安装高版本gcc目录下的libstdc++.so.6 sudo find / -name \"libstdc++.so.6*\"|grep /opt 使用之前的指令看看其是否包含需要的版本 strings /opt/gcc-14.1.0/lib64/libstdc++.so.6.0.33 | grep GLIBCXX 将文件复制到指定目录并建立新的链接 # 复制 sudo cp /opt/gcc-14.1.0/lib64/libstdc++.so.6.0.33 /usr/lib/x86_64-linux-gnu/ # 删除之前链接 sudo rm /usr/lib/x86_64-linux-gnu/libstdc++.so.6 # 创建新的链接 sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.33 /usr/lib/x86_64-linux-gnu/libstdc++.so.6 ","date":"2025-02-04","objectID":"/posts/4e49678/:5:0","tags":["gcc","g++","linux","升级"],"title":"升级GCC","uri":"/posts/4e49678/"}]